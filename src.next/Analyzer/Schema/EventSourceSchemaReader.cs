using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using Microsoft.Diagnostics.Tracing;

namespace ChilliCream.Tracing.Schema
{
    /// <summary>
    /// Parses the ETW manifest generated by the <see cref="EventSource"/> class.
    /// </summary>
    public static class EventSourceSchemaReader
    {
        private static readonly XNamespace _ns = "http://schemas.microsoft.com/win/2004/08/events";
        private static readonly XName _root = _ns + "instrumentationManifest";
        private static readonly XName _instrumentation = _ns + "instrumentation";
        private static readonly XName _events = _ns + "events";
        private static readonly XName _provider = _ns + "provider";
        private static readonly XName _tasks = _ns + "tasks";
        private static readonly XName _task = _ns + "task";
        private static readonly XName _keywords = _ns + "keywords";
        private static readonly XName _keyword = _ns + "keyword";
        private static readonly XName _opcodes = _ns + "opcodes";
        private static readonly XName _opcode = _ns + "opcode";
        private static readonly XName _event = _ns + "event";
        private static readonly XName _templates = _ns + "templates";
        private static readonly XName _template = _ns + "template";

        /// <summary>
        /// Gets the schema for the specified event source.
        /// </summary>
        /// <param name="eventSource">The event source.</param>
        /// <returns>The event schema.</returns>
        public static EventSourceSchema GetSchema(this EventSource eventSource)
        {
            if (eventSource == null)
            {
                throw new ArgumentNullException(nameof(eventSource));
            }

            return GetSchema(EventSource.GenerateManifest(eventSource.GetType(), null));
        }

        internal static EventSourceSchema GetSchema(string manifestXml)
        {
            XDocument doc = XDocument.Parse(manifestXml);

            XElement provider = doc.Root.Element(_instrumentation).Element(_events).Element(_provider);

            Guid providerGuid = (Guid)provider.Attribute("guid");
            string providerName = (string)provider.Attribute("name");
            List<EventSchema> events = new List<EventSchema>();

            foreach (XElement @event in provider.Element(_events).Elements(_event))
            {
                int eventId = (int)@event.Attribute("value");
                string eventName = (string)@event.Attribute("symbol");
                EventLevel level = ParseLevel((string)@event.Attribute("level"));
                int version = @event.Attribute("version") != null ? (int)@event.Attribute("version") : 0;

                (string name, EventTask task) task = ParseTask(provider.Element(_tasks), @event);
                (string name, EventOpcode code) opcode = ParseOpcode((string)@event.Attribute("opcode"), provider.Element(_opcodes));
                (string keywordsDescription, EventKeywords keywords) keywords = ParseKeywords(provider.Element(_keywords), @event);
                IEnumerable<string> payload = ParsePayload(provider.Element(_templates), @event);

                events.Add(
                        new EventSchema(
                            eventId,
                            eventName,
                            level,
                            task.task,
                            task.name,
                            opcode.code,
                            opcode.name,
                            keywords.keywords,
                            keywords.keywordsDescription,
                            version,
                            payload));
            }

            return new EventSourceSchema(providerGuid, providerName, events);
        }

        private static (string keywordNames, EventKeywords eventKeywords) ParseKeywords(XElement keywords, XElement @event)
        {
            long keywordsMask = 0;
            string keywordNames = (string)@event.Attribute("keywords");

            if (!string.IsNullOrWhiteSpace(keywordNames))
            {
                foreach (string keywordName in keywordNames.Split())
                {
                    XAttribute keywordsMaskAtt = keywords
                        .Elements(_keyword)
                        .Where(k => (string)k.Attribute("name") == keywordName)
                        .Select(k => k.Attribute("mask"))
                        .FirstOrDefault();

                    if (keywordsMaskAtt != null)
                    {
                        keywordsMask |= Convert.ToInt64(keywordsMaskAtt.Value, 16);
                    }
                }
            }

            return (keywordNames, (EventKeywords)keywordsMask);
        }

        private static (string name, EventTask task) ParseTask(XElement tasks, XElement @event)
        {
            string taskName = (string)@event.Attribute("task");

            int taskId = 0;
            if (!string.IsNullOrWhiteSpace(taskName))
            {
                taskId = (int)tasks
                    .Elements(_task)
                    .First(t => (string)t.Attribute("name") == taskName)
                    .Attribute("value");
            }

            return (taskName, (EventTask)taskId);
        }

        private static IEnumerable<string> ParsePayload(XElement templates, XElement @event)
        {
            XAttribute templateRef = @event.Attribute("template");
            if (templateRef == null)
            {
                // Event has no parameters/payload
                return Enumerable.Empty<string>();
            }
            else
            {
                return templates.Elements(_template)
                    .First(t => (string)t.Attribute("tid") == templateRef.Value)
                    .Elements(_ns + "data")
                    .Select(d => (string)d.Attribute("name")).ToList();
            }
        }

        private static EventLevel ParseLevel(string level)
        {
            switch (level)
            {
                case "win:Critical":
                    return EventLevel.Critical;
                case "win:Error":
                    return EventLevel.Error;
                case "win:Warning":
                    return EventLevel.Warning;
                case "win:Informational":
                    return EventLevel.Informational;
                case "win:Verbose":
                    return EventLevel.Verbose;
                case "win:LogAlways":
                default:
                    return EventLevel.LogAlways;
            }
        }

        private static (string name, EventOpcode code) ParseOpcode(string opcode, XElement opcodes)
        {
            switch (opcode)
            {
                case null:
                case "win:Info":
                    return ("Info", EventOpcode.Info);
                case "win:Start":
                    return ("Start", EventOpcode.Start);
                case "win:Stop":
                    return ("Stop", EventOpcode.Stop);
                case "win:DC_Start":
                    return ("DC_Start", EventOpcode.DataCollectionStart);
                case "win:DC_Stop":
                    return ("DC_Stop", EventOpcode.DataCollectionStop);
                case "win:Extension":
                    return ("Extension", EventOpcode.Extension);
                case "win:Reply":
                    return ("Reply", EventOpcode.Reply);
                case "win:Resume":
                    return ("Resume", EventOpcode.Resume);
                case "win:Suspend":
                    return ("Suspend", EventOpcode.Suspend);
                case "win:Send":
                    return ("Send", EventOpcode.Send);
                case "win:Receive":
                    return ("Receive", EventOpcode.Receive);
            }

            if (!string.IsNullOrWhiteSpace(opcode))
            {
                var opcodeElement = opcodes.Elements(_opcode).FirstOrDefault(o => (string)o.Attribute("name") == opcode);
                if (opcodeElement != null)
                {
                    int opcodeId = (int)opcodeElement.Attribute("value");
                    return (opcode, (EventOpcode)opcodeId);
                }
            }

            return ("Info", EventOpcode.Info);
        }
    }
}
